# Chapter 5 설계 원칙: SOLID

S: 단일 책임 원칙 (Single responsibility principle)
O: 개방-폐쇄 원칙 (Open-closed principle)
L: 리스코프 치환 원칙 (Liskov substitution principle)
I: 인터페이스 분리 원칙 (Interface segregation principle)
D: 의존 역전 원칙 (Dependency inversion principle)

## 1 단일 책임 원칙 (Single responsibility principle)
- 클래스는 단 한 개의 책임을 가져야 한다.
복잡한 비즈니스 로직 상에서 단일 기능에 대한 기준도 모호해질 수 있고 클래스 간 연관 관계를 모두
정립하여 기능을 분리하는 것은 쉽지 않을 것 같습니다.

### 1.1 단일 책임 원칙 위반이 불러오는 문제점
공통 코드를 작성할 때에 한 가지 기능이라도 다르면 책에 나와 있는 것처럼
소스를 수정함에 있어 큰 영향을 끼칠 수 있다는 것을 배웠습니다.

### 1.2 책임이란 변화에 대한 것
경험이 적은 프로그래머는 메소드를 실행하는 것이 누구인지 확인해보자
클래스의 사용자들이 각각 다른 메소드를 실행한다면 다른 책임일 가능성이 크다고 합니다.
하지만 utils와 유사하게 자주 사용하는 함수들을 모아 놓은 클래스일 수도 있는데
이런 경우도 포함되는 건지 궁금합니다.

## 2 개방 폐쇄 원칙 (Open-closed principle)
- 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
1. 기능을 변경하거나 확장 가능
2. 해당 기능을 사용하는 코드는 수정하지 않는다.
인터페이스로 추상화하여 변화에 유연하게 대처하는 것이 좋습니다.

### 2.1 개방 폐쇄 원칙이 깨질 때의 주요 증상
특정 타입일 경우에 별도 처리를 하게 되면 변경에 닫혀 있지 않을 확률이 높다.
이 증상은 하드 코딩이 되어 있을 때 발생할 가능성이 높을 것 같습니다.

### 2.2 개방 폐쇄 원칙은 유연함에 대한 것
확장 열기: 기존 코드를 이용하여 새로운 기능 구현
변화 닫기: 기존 코드를 변경시키는 행위 금지
클래스를 참조하는 다른 함수들이 있을 때, 임의로 클래스를 수정할 경우 해당 클래스를 참조하는
다른 클래스들에서 문제가 발생할 수 있습니다.

## 3 리스코프 치환 원칙 (Liskov substitution principle)
- 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.

### 3.1 리스코프 치환 원칙을 지키지 않을 때의 문제
개념적으로 상속 관계에 있을지라도 실제 구현 단계에서는 상속이 되지 않을 수 있음(예외 케이스)
예외 케이스 처리를 하게 되면 다형성에 위배됩니다.

책에 나온 FileRead의 예시는 Good code, Bad Code에서 배웠던 상세 구현을 제대로 인지하지 못한 상태에서
발생한 에러로 볼 수도 있을 것 같습니다.

### 3.2 리스코프 치환 원칙은 계약과 확장에 대한 것
하위 모듈의 상위 모듈의 상세 구현 사항을 제대로 구현해야 합니다.
상위 모듈에서는 하위 모듈이 상세 구현을 구현할 수 있도록 코드를 유도하는 과정이 필요합니다.

## 5 의존 역전 원칙 (Dependency inversion principle)
고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다. 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.
실무 코드에서 고수준 모듈은 추상화 객체가 많고 하위 모듈에는 그것을 구현하는 객체를 많이 보았습니다.

### 5.1 고수준 모듈이 저수준 모듈에 의존할 때의 문제
소스를 유지보수할 때에 구현(상세) 부분에서의 변경은 필수입니다.
하지만, 코드의 방향이 잡혀 있는 상위 모듈이 상세 변경에 영향을 많이 받게 되면 소스의 수정이 크게 발생합니다.
저수준 모듈이 변경되더라도 고수준 모듈은 변경되지 않도록 하는 것이 **의존 역전 원칙**입니다.

### 5.2 의존 역전 원칙을 통한 변경의 유연함 확보
A 객체가 B 객체의 변화에 영향을 받는 것을 의존한다고 합니다.
고수준 모듈이 저수준 모듈에 의존하는 방향은 앞서 이야기 된 바와 같이 유지보수에 부담을 주므로
인터페이스로 한 단계 상속 받아 고수준 모듈과 저수준 모듈이 둘 다 의존하도록 만들었습니다.

### 5.3 소스 코드 의존과 런타임 의존
의존 역전 원칙은 소스 코드의 의존을 역전시킴으로써 변경(유지보수)의 유연함 확보를 함에 목적을 둠
런타임 상에서는 의존이 역전되지 않았습니다.

### 5.4 의존 역전 원칙과 패키지
기존 하위 모듈의 타입의 소유를 상위 모듈에 위치함으로써 기능의 모듈화를 가능하게 하여
기능의 분리 및 교체가 원활하게 될 것 같습니다.

## 6 SOLID 정리
복잡한 비즈니스 로직을 사용하고 일정을 맞추다 보면 지키기 어려운 원칙들일 수도 있을 것 같습니다.
하지만, 복잡한 로직에 복잡한 코드가 되지 않도록 개발자들은 노력을 기울여야 할 것 같습니다.